**SpringBoot 2.x | 第十九篇：轻松搞定数据验证（一）**

对于任何一个应用而言，客户端做的数据有效性验证都不是安全有效的，而数据验证又是一个企业级项目架构上最为基础的功能模块，这时候就要求我们在服务端接收到数据的时候也对数据的有效性进行验证。

为什么这么说呢？往往我们在编写程序的时候都会感觉后台的验证无关紧要，毕竟客户端已经做过验证了，后端没必要在浪费资源对数据进行验证了，但恰恰是这种思维最为容易被别人钻空子。

毕竟只要有点开发经验的都知道，我们完全可以模拟 HTTP 请求到后台地址，模拟请求过程中发送一些涉及系统安全的数据到后台，后果可想而知….

1、为什么要轻松搞定？
相信通过上面的阅读，大家对数据验证的重要性有了一定的了解，那么为什么我这里要说 轻松搞定呢？

下面这段代码很多人一定见到过，就是对参数进行有效性校验，但仔细观察的话就会发现；随着参数的增加，格式的变化，校验数据有效性的代码愈发的繁琐杂乱，一点都不轻松

2、本章目标
通过 Spring Boot 完成参数后台数据校验，轻松搞定数据有效性验证，留出更多的时间来和小姐姐聊天…

3、具体代码
通过上面的阅读大家也大致能了解到为啥需要对异常进行全局捕获了，接下来就看看 Spring Boot 提供的解决方案

JSR-303 注释介绍
这里只列举了 javax.validation 包下的注解，同理在 spring-boot-starter-web 包中也存在 hibernate-validator 验证包，里面包含了一些 javax.validation 没有的注解，有兴趣的可以看看
注解	                                    说明
@NotNull	                            限制必须不为null
@NotEmpty	                            验证注解的元素值不为 null 且不为空（字符串长度不为0、集合大小不为0）
@NotBlank	                            验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格
@Pattern(value)	                        限制必须符合指定的正则表达式
@Size(max,min)	                        限制字符长度必须在 min 到 max 之间（也可以用在集合上）
@Email	                                验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式
@Max(value)	                            限制必须为一个不大于指定值的数字
@Min(value)	                            限制必须为一个不小于指定值的数字
@DecimalMax(value)	                    限制必须为一个不大于指定值的数字
@DecimalMin(value)	                    限制必须为一个不小于指定值的数字
@Null	                                限制只能为null（很少用）
@AssertFalse	                        限制必须为false （很少用）
@AssertTrue	                            限制必须为true （很少用）
@Past	                                限制必须是一个过去的日期
@Future	                                限制必须是一个将来的日期
@Digits(integer,fraction)	            限制必须为一个小数，且整数部分的位数不能超过 integer，小数部分的位数不能超过 fraction （很少用）

实体类
为了体现 validation 的强大，分别演示普通参数属性验证与对象的验证

控制层
与前面的代码相比，新的代码中仅仅多了几个注解而已。（此处只是为了图方便写在了 Controller 层，同理你可以将它作用在 Service 层）
注解介绍
@Validated： 开启数据有效性校验，添加在类上即为验证方法，添加在方法参数中即为验证参数对象。（添加在方法上无效）
@NotBlank： 被注释的字符串不允许为空（value.trim() > 0 ? true : false）
@Length： 被注释的字符串的大小必须在指定的范围内
@NotNull： 被注释的字段不允许为空(value != null ? true : false)
@DecimalMin： 被注释的字段必须大于或等于指定的数值

测试
完成准备事项后，启动 Chapter18Application 自行测试即可，测试手段相信大伙都不陌生了，如 浏览器、postman、junit、swagger，此处基于 postman，如果你觉得自带的异常信息不够友好，那么配上一起来学SpringBoot | 第十八篇：轻松搞定全局异常 可以轻松搞定…



**SpringBoot 2.x 第二十篇：轻松搞定数据验证（二）**

一起来学SpringBoot | 第十九篇：轻松搞定数据验证（一） 中介绍了数据有效性校验的重要性，也简单介绍了如何用轻松的方式搞定数据有效性校验，但是当系统自带的注解无法满足我们的要求时候应该咋办呢？这就是本章将给各位介绍的自定义 Validator 注解

1、为何要自定义
javax.validation 包与 hibernate-validator 包中存在的注解几乎可以满足大部分的要求，又拥有基于正则表达式的@Pattern，为什么还需要自己去定义呢？
原因如下
正则效率不高
正则可读性不好
正则门槛较高，很多开发者并不会编写正则表达式

2、本章目标
熟悉 ConstraintValidator 接口并且编写自己的数据验证注解

3、具体代码

自定义注解
这里定义了一个 @DateTime 注解，在该注解上标注了 @Constraint 注解，它的作用就是指定一个具体的校验器类
关键字段（强制性）
message： 验证失败提示的消息内容
groups： 为约束指定验证组（非常不错的一个功能，**下一章介绍**）
payload： 不太清楚（欢迎留言交流）

具体验证
定义校验器类 DateTimeValidator 实现 ConstraintValidator 接口，实现接口后需要实现它里面的 initialize： 与 isValid： 方法。
方法介绍
initialize： 主要用于初始化，它可以获得当前注解的所有属性
isValid： 进行约束验证的主体方法，其中 value 就是验证参数的具体实例，context 代表约束执行的上下文环境。
这里的验证方式虽然简单，但职责明确；为空验证可以使用 @NotBlank、@NotNull、@NotEmpty 等注解来进行控制，而不是在一个注解中做各种各样的规则判断，应该职责分离


**SpringBoot 2.x 第二十一篇：轻松搞定数据验证（三）**

前面两章中详细介绍了数据有效性校验的重要性、自定有数据有效性校验注解 本章也是轻松搞定数据验证的最后一篇， 一起来揭开神秘的分组验证

1、分组验证
有的时候，我们对一个实体类需要有多种验证方式，在不同的情况下使用不同验证方式，比如说对于一个实体类来的 id 来说，新增的时候是不需要的，对于更新时是必须的，这个时候你是选择写一个实体类呢还是写两个呢？
在自定有数据有效性校验注解中介绍到注解需要有一个 groups 属性，这个属性的作用又是什么呢？
接下来就让我们看看如何用一个验证类实现多个接口之间不同规则的验证…

2、本章目标
利用一个验证类实现多个接口之间不同规则的验证…

3、具体代码

分组验证器
定义一个验证组，里面写上不同的空接口类即可，用于分组

实体类
groups 属性的作用就让 @Validated 注解只验证与自身 value 属性相匹配的字段，可多个，只要满足就会去纳入验证范围；我们都知道针对新增的数据我们并不需要验证 ID 是否存在，我们只在做修改操作的时候需要用到，因此这里将 ID 字段归纳到 Groups.Update.class 中去，而其它字段是不论新增还是修改都需要用到所以归纳到 Groups.Default.class 中…

控制层
创建一个 ValidateController 类，然后定义好 insert、update 俩个方法，比由于 insert 方法并不关心 ID 字段，所以这里 @Validated 的 value 属性写成 Groups.Default.class 就可以了；而 update 方法需要去验证 ID 是否为空，所以此处 @Validated 注解的 value 属性值就要写成 Groups.Default.class, Groups.Update.class；代表只要是这分组下的都需要进行数据有效性校验操作…